var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Modules = [DGGS]","category":"page"},{"location":"api/#DGGS.Apertures","page":"API","title":"DGGS.Apertures","text":"DGGRID apertures\n\n\n\n\n\n","category":"constant"},{"location":"api/#DGGS.Projections","page":"API","title":"DGGS.Projections","text":"DGGRID projections\n\n\n\n\n\n","category":"constant"},{"location":"api/#DGGS.Topologies","page":"API","title":"DGGS.Topologies","text":"DGGRID topologies\n\n\n\n\n\n","category":"constant"},{"location":"api/#DGGS.AbstractCube","page":"API","title":"DGGS.AbstractCube","text":"Subtypes must have field data::YAXArray\n\n\n\n\n\n","category":"type"},{"location":"api/#DGGS.AbstractGrid","page":"API","title":"DGGS.AbstractGrid","text":"A set of points defining a grid as a voronoi partition.  Points must be geographical coordinates (lon, lat) and stored as a KDTree in the filed data.\n\n\n\n\n\n","category":"type"},{"location":"api/#DGGS.CellCube-Tuple{GeoCube, DGGS.AbstractGrid}","page":"API","title":"DGGS.CellCube","text":"Import geographical data cube into a DGGS\n\nTransforms a data cube with spatial index dimensions longitude and latitude into a data cube with the cell id as a single spatial index dimension. Re-gridding is done using the average value of all geographical coordinates belonging to a particular cell defined by the grid specification grid_spec.\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.DgGrid-Tuple{Symbol, Union{Nothing, Int64}, Union{Nothing, Symbol}, Int64}","page":"API","title":"DGGS.DgGrid","text":"Create a grid using DGGRID parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.GeoCube-Tuple{CellCube}","page":"API","title":"DGGS.GeoCube","text":"Export cell data cube into a traditional geographical one\n\nTransforms a data cube with one spatial index dimensions, i. e., the cell id, into a traditional geographical data cube with two spatial index dimensions longitude and latitude. Values are taken from the nearest cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.Grid-Tuple{AbstractMatrix{<:Number}}","page":"API","title":"DGGS.Grid","text":"Create a Grid using coordinates of center points describing a voronoi partition. center_points must have one point per column with 2 rows for longitude and latitude, respectiveley.\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.call_dggrid-Tuple{Dict}","page":"API","title":"DGGS.call_dggrid","text":"Execute sytem call of DGGRID binary\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.get_cell_boundaries-Tuple{Symbol, Symbol, Int64}","page":"API","title":"DGGS.get_cell_boundaries","text":"Get a GeoDataFrame with boundary polygons for each cell\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.get_cell_ids-Tuple{DGGS.AbstractGrid, Union{Number, AbstractVector}, Union{Number, AbstractVector}}","page":"API","title":"DGGS.get_cell_ids","text":"Get cell ids given geographic corrdinates\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.get_children_cell_ids-Tuple{Vector{<:DGGS.AbstractGrid}, Int64, Int64}","page":"API","title":"DGGS.get_children_cell_ids","text":"Get the cell ids of the children associated to each cell id of the parent level\n\nNote that a child often has multiple parents. The cells at different resolutions are only in rectangular pyramids perfectly nested. Returns a Dict with parent cell id as keys and children cell ids as values\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.get_cube_pyramid-Tuple{Vector{<:DGGS.AbstractGrid}, CellCube}","page":"API","title":"DGGS.get_cube_pyramid","text":"Get a cell data cube pyramid\n\nCalculates a stack of cell data cubes with incrementally lower levels based on the same data as provided by cell_cube. Cell values are combined according to the provided aggregate_function.\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.get_geo_coords-Tuple{DGGS.AbstractGrid, AbstractVector}","page":"API","title":"DGGS.get_geo_coords","text":"Convert cell id to geographic coordinate of cell center\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.get_geo_coords-Tuple{DGGS.AbstractGrid, Int64}","page":"API","title":"DGGS.get_geo_coords","text":"Convert cell id to geographic coordinate of cell center\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.get_grid_table-Tuple{Symbol, Symbol, Int64}","page":"API","title":"DGGS.get_grid_table","text":"Get a DataFrame of cell center points\n\n\n\n\n\n","category":"method"},{"location":"api/#DGGS.knn-Tuple{DGGS.AbstractGrid, Real, Real, Integer}","page":"API","title":"DGGS.knn","text":"Get cell ids of k nearest neighbors arround a cell\n\n\n\n\n\n","category":"method"},{"location":"background/#The-background-behind-Discrete-Global-Grid-Systems-(DGGS)","page":"Background","title":"The background behind Discrete Global Grid Systems (DGGS)","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"A Discrete Global Grid Systems (DGGS) tessellate the surface of the earth with hierarchical cells of equal area. This minimizes distortion and loading time of large geospatial datasets, which is crucial in spatial statistics and building Machine Learning models.","category":"page"},{"location":"background/#Why-to-use-a-DGGS","page":"Background","title":"Why to use a DGGS","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"multi resolutions\nchunking and compression\nspherical properties\nequal area","category":"page"},{"location":"background/#DGGS-creation","page":"Background","title":"DGGS creation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Take a platonic solid (e.g. icosahedron)\nBlow it up so that it s size fits the radius of the earth\nChose a rotation of the polyhedron relative to the  (e.g. those used in the Dymaxion projection so that the evrtices of the polyhedrons with high distortions are in the oceans)\nTessellate the faces of the polyhedron (e.g. triangles, diamonds, or hexagons). One must introduce 12 pentagons at the vertices of the polyhedron to enable a tesselation of the 3D surface with hexagons. Polygons are regular on the faces of the polyhedron but may be distorted after re-projection to the sphere.\nRedo the tessellation with increasing resolutions forming a grid system","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: ) By Justin Kunimune - Own work, Public Domain, https://commons.wikimedia.org/w/index.php?curid=65694588","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(Image: )","category":"page"},{"location":"background/#Projections","page":"Background","title":"Projections","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"ISEA: Icosahedral Snyder Equal Area projection Snyder 1992. Distortions are low in area but high in shape.\nFULLER: Icosahedral Dymaxion projection of Fuller in 1975. Distortions are moderate in both area and shape. More details at Gregory et al. 2008","category":"page"},{"location":"background/#Grid-cells","page":"Background","title":"Grid cells","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"DGGS cells are optimized towards having equal area leading into an irregular grid in geographical lon/lat space Any grid, including those used in a DGGS, can be represented as a Voronoi partition of the cell center coordinates These coordinates are stored in a KD-Tree (Similar in python xarrys extension Xoak)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"It is important to give nearby cells a similar cell id. This allows faster indexing and loading times, because the chunking is based on cell id. The cell id encodes the 1D (memory address and cell id) curve to traverse the the 2D surface (geographical coordinates). These space-filling curves are often recursively defined fractals. Solutions for the 2-D plane are the Hilbert and Gosper curve for rectangular and hexagonal grids, respectively. The Superfund grid is a solution for the sphere surface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DGGS","category":"page"},{"location":"#DGGS.jl:-A-Discrete-Global-Grid-System-for-Julia","page":"Home","title":"DGGS.jl: A Discrete Global Grid System for Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DGGS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DGGS.jl is a Julia Package for scalable geospatial analysis using Discrete Global Grid Systems (DGGS), which tessellate the surface of the earth with hierarchical cells of equal area, minimizing distortion and loading time of large geospatial datasets, which is crucial in spatial statistics and building Machine Learning models.","category":"page"},{"location":"#Get-Started","page":"Home","title":"Get Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install DGGS.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DGGS\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create a simple grid:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DGGS\ngrid = create_toy_grid()","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Create-a-Discrete-Global-Grid-System-(DGGS)","page":"Tutorial","title":"Create a Discrete Global Grid System (DGGS)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create a data cube in geographical coordinates:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DGGS\nlon_range = -180:180\nlat_range = -90:90\ndata = [exp(cosd(lon)) + 3(lat / 90) for lon in lon_range, lat in lat_range]\ngeo_cube = GeoCube(data, lat_range, lon_range)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\nplot_map(geo_cube)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's create a DGGS using Synder Equal Area projection (ISEA), an aperture of 4 (number of child cells of a given parent cell), a hexagonal grid shape at 3 different levels:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dggs = DgGlobalGridSystem(geo_cube, 3, :isea, 4, :hexagon)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The data cube at the highest level has only one spatial index dimension, i.e. the cell id:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dggs","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Plot the DGGS at a given level","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_map(dggs[3])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A DGGS cell represent all points within its boundary polygon. This acts as a pooling mechanism. The hexagonal topology is easily recognizable at this low level.","category":"page"},{"location":"tutorial/#Create-grids","page":"Tutorial","title":"Create grids","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using DGGRID:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DGGS\ngrid1 = DgGrid(:isea, 4, :hexagon, 3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using a vector of geographical coordinates for center points:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"center_points = [-170 -80; -165.12 81.12; -160 90]\ngrid2 = Grid(center_points')","category":"page"},{"location":"tutorial/#Explore-the-grid","page":"Tutorial","title":"Explore the grid","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A DGGS consists of multiple grids with varying levels. Let's create our first grid to explore its properties:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DGGS\ngrid = DgGrid(:isea, 4, :hexagon, 3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create a data frame containing the center point or boundary polygon for all cells of the grid:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"boundaries = get_cell_boundaries(grid)\ncenters = get_cell_centers(grid)\n\nprintln(boundaries[1:5,:])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The data frames can be saved e.g. as geojson to be used in other tools like GIS:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeoDataFrames\nGeoDataFrames.write(\"boundaries.geojson\", boundaries)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Convert points between cell id and geographic coordinates:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"get_cell_ids(grid, 80, -170)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and vice versa:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"get_geo_coords(grid, 5)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The coordinates may differ slightly, because a cell covers all points of a given area and only the center point is returned. This tutorial uses very low levels to demonstrate the properties of a DGGS. In practice, much higher level levels should be chosen for spatial analysis, diminishing these inaccuracies.","category":"page"},{"location":"tutorial/#Import-Earth-System-Data-Cube-(ESDC)","page":"Tutorial","title":"Import Earth System Data Cube (ESDC)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Earth System Data Lab provides global data about 42 features about temperature, precipitation, among others. The data is stored online in the Earth System Data Cube (ESDC) and can be imported with the following commands:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DGGS\nusing EarthDataLab\nesdc_cube = esdc(res=\"low\")\ngeo_cube = GeoCube(esdc_cube)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's create a subset containing vegetation data of Asia in the year 2020:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sub_geo_cube =  geo_cube[region=\"Asia\", time=2020:2020, Variable=\"ndvi\"]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that one can only plot a cube if the only remaining axes are longitude and latitude. This we need to subset it to plot the first time point of the imported raster data:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\nplot_map(sub_geo_cube[time = DateTime(\"2020-01-05T00:00:00\")])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can create a DGGS from it:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dggs = DgGlobalGridSystem(sub_geo_cube, :isea4h, 6)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And plot the DGGS at the first time point with different resolutions:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_map(dggs[5][time=DateTime(\"2020-01-01T01:00:00\")])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_map(dggs[4][time=DateTime(\"2020-01-01T01:00:00\")])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Due to the nature of the vegetation index, areas in the oceans are undefined. Thus, parent cells having any undefined value are undefined as well, resulting in undefined coastal areas at lower resolution. We can prevent this by providing a custom aggregation function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Statistics\naggregate_skip_undef(value) = value |> filter(! isnan) |> mean\n\ndggs2 = DgGlobalGridSystem(sub_geo_cube, :isea4h, 6; aggregation_function = aggregate_skip_undef)\nplot_map(dggs2[4][time=DateTime(\"2020-01-01T01:00:00\")])","category":"page"},{"location":"tutorial/#Import-Zarr-Arrays","page":"Tutorial","title":"Import Zarr Arrays","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Load the zarr data into a YAXArray:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Zarr, YAXArrays\nurl = \"gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/\"\ngeo_dataset = open_dataset(zopen(url, consolidated=true))\ngeo_array = geo_dataset[\"tas\"]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Transform the cooordinates and create the GeoCube:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DGGS\ndata = circshift(geo_array[:, :, 1], length(geo_array.lon) / 2)\nlatitudes = geo_array.lat\nlongitudes = geo_array.lon .- 180\ngeo_cube = GeoCube(data, latitudes, longitudes)\nplot_map(geo_cube)","category":"page"},{"location":"tutorial/#Import-NetCDF-files","page":"Tutorial","title":"Import NetCDF files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we will explore Sea surface temperatures collected by PCMDI for use by the IPCC stored in a NetCDF file. Download the NetCDF file into a YAXArray:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using YAXArrays\nusing NetCDF\nusing Downloads\nurl = \"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\"\nfilename = Downloads.download(url, \"tos_O1_2001-2002.nc\")\ngeo_array = YAXArrays.Cube(\"tos_O1_2001-2002.nc\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Lets have a look at the first time point of the raw data:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\nheatmap(geo_array[:,:,1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Transform the cooordinates and create the GeoCube:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DGGS\ndata = circshift(geo_array[:,:,1], 90)\nlatitudes = geo_array.lat\nlongitudes = geo_array.lon .- 180\ngeo_cube = GeoCube(data, latitudes, longitudes)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Plot the imported geo data cube:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_map(geo_cube)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since this dataset is about ocean temperature, we do not have cells on the land area.","category":"page"}]
}
